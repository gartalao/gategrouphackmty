# PROMPT PARA CURSOR - Arreglar Detecci√≥n en Tiempo Real con Gemini

## CONTEXTO DEL PROYECTO

Sistema de detecci√≥n visual de productos en tiempo real para trolleys de catering a√©reo usando **Gemini Robotics-ER 1.5**.

**Branch actual**: `api-streaming-functional`

---

## PROBLEMA ACTUAL

La web app (http://localhost:3002) muestra **"Desconectado - Sin conexi√≥n al servidor"** aunque:
- ‚úÖ Backend est√° corriendo en puerto 3001
- ‚úÖ Web app est√° corriendo en puerto 3002
- ‚úÖ Archivos .env existen
- ‚ùå WebSocket NO se conecta desde el frontend

---

## ARQUITECTURA ACTUAL

```
üåê Web Camera App (React + Vite + TypeScript)
  Puerto: 3002
  Ruta: apps/web-camera/
  
    ‚Üì WebSocket (2 fps)
    
üîß Backend API (Node.js + Express + Socket.IO)
  Puerto: 3001
  Ruta: apps/api/
  WebSocket namespace: /ws
  
    ‚Üì REST API v1beta
    
ü§ñ Gemini Robotics-ER 1.5
  Modelo: gemini-robotics-er-1.5-preview
  
    ‚Üì JSON Response
    
üóÑÔ∏è PostgreSQL (Neon)
  Modelo: ProductDetection, Scan, Product, User, Trolley
```

---

## ARCHIVOS CLAVE

### Backend (Node.js):

**`apps/api/src/index.js`**:
- Servidor Express + Socket.IO
- Namespace: `/ws`
- CORS configurado para `*`
- Puerto: 3001

**`apps/api/routes/videoStream.js`**:
- WebSocket events: `start_scan`, `frame`, `end_scan`
- Emit: `product_detected`
- Auth: Opcional (guest mode)
- Auto-maneja trolleyId y operatorId inexistentes

**`apps/api/services/geminiService.js`**:
- Modelo FORZADO: `gemini-robotics-er-1.5-preview`
- REST API: `https://generativelanguage.googleapis.com/v1beta/models/gemini-robotics-er-1.5-preview:generateContent`
- Prompt optimizado para COLOR, FORMA y TEXTO
- Thinking budget: 0 (latencia m√≠nima)

**`apps/api/.env`**:
```env
DATABASE_URL="postgresql://neondb_owner:npg_drmFEg6auN9C@ep-little-forest-adbtr9zw-pooler.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require"
GEMINI_API_KEY=AIzaSyAvU5F7oYGHxi-04bEIN5v5zwCSQg3cFco
GEMINI_MODEL=gemini-robotics-er-1.5-preview
PORT=3001
DETECTION_CONFIDENCE_THRESHOLD=0.70
PRODUCT_COOLDOWN_MS=1200
```

### Frontend (React + TypeScript):

**`apps/web-camera/src/pages/LiveRecording.tsx`**:
- Componente principal de grabaci√≥n
- useEffect NO auto-inicializa (espera clic en "Iniciar")
- Funci√≥n `initializeSession()` conecta WebSocket
- Funci√≥n `handleFrameCapture()` env√≠a frames
- Funci√≥n `handleProductDetected()` recibe detecciones

**`apps/web-camera/src/services/websocketService.ts`**:
- Cliente Socket.IO
- Conecta a `${WS_URL}/ws`
- M√©todos: connect(), startScan(), sendFrame(), endScan()
- Listeners: 'product_detected'

**`apps/web-camera/.env`**:
```env
VITE_WS_URL=ws://localhost:3001
VITE_API_URL=http://localhost:3001
VITE_DEV_MODE=true
```

### Base de Datos:

**`prisma/schema.prisma`**:
- Product (con visualDescription y detectionKeywords)
- Scan (con trolleyId, operatorId, startedAt, endedAt)
- ProductDetection (scanId, productId, confidence, detectedAt)
- User, Trolley, Flight, FlightRequirement

**`seed-products.js`**:
- 8 productos con visual descriptions:
  - Coca-Cola 350ml, Coca-Cola Zero 350ml, Sprite 350ml, Pepsi 350ml
  - Agua Natural 500ml
  - Lays Original 100gr, Lays Queso 100gr, Doritos Nacho 100gr

---

## ESTADO ACTUAL DEL SISTEMA

### Backend (FUNCIONANDO):
```
‚úÖ Server running on http://localhost:3001
‚úÖ WebSocket available at ws://localhost:3001/ws
‚úÖ Gemini Mode: ü§ñ REAL (Production)
‚úÖ Database: üü¢ Connected
[Gemini] Configurado con modelo: gemini-robotics-er-1.5-preview
[Gemini] URL: https://generativelanguage.googleapis.com/v1beta/models/gemini-robotics-er-1.5-preview:generateContent
```

### Frontend (CARGA PERO NO CONECTA):
```
‚ùå Estado: "Desconectado - WebSocket al servidor"
‚ùå Bot√≥n "Iniciar Streaming" deshabilitado
‚ùå No se conecta a ws://localhost:3001/ws
```

---

## REQUERIMIENTOS CR√çTICOS

### 1. DETECCI√ìN EN TIEMPO REAL (OBLIGATORIO):
- Al hacer clic en "Iniciar Streaming", debe conectarse autom√°ticamente
- Streaming continuo a 2 fps (cada 500ms)
- Frames se env√≠an autom√°ticamente al backend
- Backend analiza con Gemini autom√°ticamente
- Detecciones aparecen autom√°ticamente en UI

### 2. GEMINI ROBOTICS-ER 1.5 (OBLIGATORIO):
- Modelo: `gemini-robotics-er-1.5-preview`
- API version: v1beta
- Endpoint: `https://generativelanguage.googleapis.com/v1beta/models/gemini-robotics-er-1.5-preview:generateContent`
- Thinking budget: 0
- Temperature: 0.2

### 3. DETECCI√ìN POR COLOR, FORMA Y TEXTO (OBLIGATORIO):
- Prompt debe buscar activamente por COLOR (roja, verde, azul, negra, amarilla, naranja)
- Prompt debe buscar por FORMA (latas cil√≠ndricas, botellas, bolsas)
- Prompt debe buscar por TEXTO visible (Coca-Cola, Sprite, Pepsi, Lays, Doritos, Agua)
- NO usar SKUs ni c√≥digos de barras

### 4. UI SIMPLIFICADA (OBLIGATORIO):
- Solo bot√≥n "‚ñ∂ Iniciar Streaming" / "‚èπ Detener Streaming"
- NO botones de "Foto Manual" ni "Pausar"
- Streaming 100% autom√°tico despu√©s del clic

### 5. SERVER-SIDE PROCESSING (OBLIGATORIO):
- API key de Gemini SOLO en backend
- Frames se env√≠an al backend v√≠a WebSocket
- Backend llama a Gemini REST API
- NUNCA exponer API key en cliente

---

## TAREAS PARA ARREGLAR

### 1. Verificar y Arreglar WebSocket Connection

**Problema**: Frontend no conecta a `ws://localhost:3001/ws`

**Archivos a revisar**:
- `apps/web-camera/src/pages/LiveRecording.tsx` l√≠neas 47-95
- `apps/web-camera/src/services/websocketService.ts` l√≠neas 47-84
- `apps/api/src/index.js` l√≠neas 12-19 (configuraci√≥n Socket.IO)
- `apps/api/routes/videoStream.js` l√≠neas 50-74 (middleware de auth)

**Verificar**:
1. ¬øSe llama `initializeSession()` al montar el componente?
2. ¬øEl WebSocketService conecta correctamente?
3. ¬øHay errores en consola del navegador?
4. ¬øEl CORS est√° configurado para permitir conexi√≥n?
5. ¬øEl auth middleware permite conexi√≥n sin token?

**Soluci√≥n esperada**:
- LiveRecording debe llamar a `initializeSession()` al hacer clic en "Iniciar"
- WebSocket debe conectar a `ws://localhost:3001/ws`
- Backend debe aceptar conexi√≥n sin token (guest mode)
- Estado debe cambiar a "Backend conectado" (verde)

### 2. Asegurar Auto-Inicio de Streaming

**Problema**: Despu√©s de conectar, el streaming no inicia autom√°ticamente

**Archivos a revisar**:
- `apps/web-camera/src/pages/LiveRecording.tsx` l√≠neas 155-164 (`handleStartRecording`)
- `apps/web-camera/src/components/CameraView.tsx` l√≠neas 35-42 (useEffect para isStreaming)

**Verificar**:
1. ¬ø`handleStartRecording` llama a `initializeSession()`?
2. ¬ø`CameraView` recibe prop `isStreaming`?
3. ¬øEl useEffect de CameraView inicia captura cuando `isStreaming` es true?

**Soluci√≥n esperada**:
- Al hacer clic en "Iniciar", llama `initializeSession()`
- Conecta WebSocket
- Llama `startScan()` y obtiene scanId
- `setIsRecording(true)` activa CameraView
- CameraView inicia streaming a 2 fps autom√°ticamente

### 3. Verificar Backend Procesamiento

**Problema**: Backend recibe frames pero puede estar fallando

**Archivos a revisar**:
- `apps/api/routes/videoStream.js` l√≠neas 159-247 (evento 'frame')
- `apps/api/services/geminiService.js` l√≠neas 78-130 (analyzeFrameReal)

**Verificar**:
1. ¬øEl evento 'frame' se est√° recibiendo?
2. ¬øGemini API se llama correctamente?
3. ¬øHay errores 404 del modelo?
4. ¬øEl parseo JSON funciona?

**Logs esperados del backend**:
```
[WS] User guest connected
[WS] Scan X started for trolley 1
[WS] Frame received: frame_1_...
[WS] Product detected: Coca-Cola 350ml (confidence: 0.92)
```

### 4. Limpiar C√≥digo Viejo y Cache

**Problema**: Puede haber c√≥digo viejo cacheado

**Acciones**:
1. Eliminar `node_modules/.cache/` en ambas apps
2. Reiniciar con `killall -9 node nodemon vite`
3. npm install en ambas apps
4. Verificar que no haya archivos duplicados (.ts y .js del mismo archivo)

---

## PRODUCTOS PARA DETECTAR

Base de datos tiene 8 productos:

```javascript
[
  {
    name: 'Coca-Cola 350ml',
    visualDescription: 'Lata roja con logo blanco de Coca-Cola',
    detectionKeywords: ['coca', 'cola', 'lata roja', 'logo blanco']
  },
  {
    name: 'Coca-Cola Zero 350ml',
    visualDescription: 'Lata negra con logo rojo y plata de Coca-Cola Zero',
    detectionKeywords: ['coca', 'zero', 'lata negra']
  },
  {
    name: 'Sprite 350ml',
    visualDescription: 'Lata verde con logo Sprite en blanco y amarillo',
    detectionKeywords: ['sprite', 'lata verde', 'lim√≥n']
  },
  {
    name: 'Pepsi 350ml',
    visualDescription: 'Lata azul con logo blanco de Pepsi',
    detectionKeywords: ['pepsi', 'lata azul']
  },
  {
    name: 'Agua Natural 500ml',
    visualDescription: 'Botella de pl√°stico transparente con agua',
    detectionKeywords: ['agua', 'botella transparente']
  },
  {
    name: 'Lays Original 100gr',
    visualDescription: 'Bolsa de papas amarilla con logo rojo Lays',
    detectionKeywords: ['lays', 'bolsa amarilla', 'papas']
  },
  {
    name: 'Lays Queso 100gr',
    visualDescription: 'Bolsa de papas naranja con logo rojo Lays sabor queso',
    detectionKeywords: ['lays', 'queso', 'bolsa naranja']
  },
  {
    name: 'Doritos Nacho 100gr',
    visualDescription: 'Bolsa roja con tri√°ngulos amarillos, logo Doritos',
    detectionKeywords: ['doritos', 'bolsa roja', 'nacho']
  }
]
```

---

## FLUJO ESPERADO (E2E)

```
1. Usuario abre http://localhost:3002/
   ‚Üì
2. LiveRecording.tsx se monta
   - NO auto-conecta (espera clic en "Iniciar")
   - Estado: "Desconectado"
   ‚Üì
3. Usuario hace clic en "‚ñ∂ Iniciar Streaming"
   ‚Üì
4. handleStartRecording() ejecuta:
   - Llama initializeSession()
   - WebSocket conecta a ws://localhost:3001/ws
   - Backend acepta (no requiere token)
   ‚úÖ Estado cambia a "Backend conectado"
   ‚Üì
5. WebSocket emite 'start_scan' {trolleyId: 123, operatorId: 456}
   - Backend verifica trolley ‚Üí usa trolley 1
   - Backend verifica operator ‚Üí usa operator 1
   - Backend crea Scan
   ‚úÖ Retorna {scanId: X, status: 'recording'}
   ‚Üì
6. Frontend recibe scanId
   - scanIdRef.current = scanId
   - setIsRecording(true)
   ‚úÖ CameraView recibe isStreaming=true
   ‚Üì
7. CameraView useEffect detecta isStreaming=true
   - Llama cameraService.startCapture(500)
   ‚úÖ Inicia streaming a 2 fps
   ‚Üì
8. Cada 500ms autom√°ticamente:
   - Captura frame del video
   - Convierte a base64 JPEG
   - Llama handleFrameCapture(imageData)
   ‚Üì
9. handleFrameCapture():
   - Extrae base64 sin prefijo
   - wsService.sendFrame({scanId, frameId, jpegBase64, ts})
   ‚úÖ Frame enviado al backend
   ‚Üì
10. Backend recibe evento 'frame':
    - Verifica scan activo
    - Obtiene cat√°logo de productos (8 productos)
    - Llama analyzeFrame(jpegBase64, products, {threshold: 0.70})
    ‚Üì
11. analyzeFrame() en geminiService:
    - Construye prompt con 8 productos
    - POST a Gemini REST API
    - URL: https://generativelanguage.googleapis.com/v1beta/models/gemini-robotics-er-1.5-preview:generateContent
    - Body: {contents, generationConfig: {temperature: 0.2, thinkingConfig: {thinkingBudget: 0}}}
    ‚Üì
12. Gemini analiza (~1-1.5s):
    - Busca productos por COLOR, FORMA y TEXTO
    - Retorna: {detected, product_name, confidence, action, box_2d}
    ‚Üì
13. Backend valida resultado:
    - detected === true
    - product_name existe en cat√°logo
    - confidence >= 0.70
    - No en cooldown (1200ms)
    ‚Üì
14. Backend INSERT ProductDetection
    ‚Üì
15. Backend emit 'product_detected':
    - {trolley_id, product_id, product_name, detected_at, confidence, box_2d}
    ‚Üì
16. Frontend recibe evento 'product_detected':
    - handleProductDetected()
    - setDetections([newDetection, ...prev])
    ‚úÖ DetectionFeed muestra producto

LATENCIA TOTAL: ~1-2 segundos
```

---

## CONFIGURACI√ìN ACTUAL

### Variables de Entorno (apps/api/.env):
```env
DATABASE_URL="postgresql://neondb_owner:npg_drmFEg6auN9C@ep-little-forest-adbtr9zw-pooler.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require"
GEMINI_API_KEY=AIzaSyAvU5F7oYGHxi-04bEIN5v5zwCSQg3cFco
GEMINI_MODEL=gemini-robotics-er-1.5-preview
GEMINI_FAKE=0
PORT=3001
DETECTION_CONFIDENCE_THRESHOLD=0.70
PRODUCT_COOLDOWN_MS=1200
JWT_SECRET=smart-trolley-secret-change-in-production
```

### Variables de Entorno (apps/web-camera/.env):
```env
VITE_WS_URL=ws://localhost:3001
VITE_API_URL=http://localhost:3001
VITE_DEV_MODE=true
```

---

## C√ìDIGO ACTUAL RELEVANTE

### WebSocket Backend (apps/api/src/index.js):
```javascript
const io = new Server(httpServer, {
  cors: {
    origin: '*',  // Permite cualquier origen
    methods: ['GET', 'POST'],
  },
  maxHttpBufferSize: 10e6,
});

initializeVideoStream(io); // Inicializa namespace /ws
```

### WebSocket Namespace (apps/api/routes/videoStream.js):
```javascript
function initializeVideoStream(io) {
  const wsNamespace = io.of('/ws');

  wsNamespace.use((socket, next) => {
    const token = socket.handshake.auth.token || socket.handshake.query.token;
    
    if (token) {
      const user = verifyToken(token);
      socket.user = user || { userId: 0, username: 'guest', role: 'operator' };
    } else {
      // Sin token, usar guest (DEV MODE)
      socket.user = { userId: 0, username: 'guest', role: 'operator' };
    }
    
    next(); // PERMITE conexi√≥n
  });

  wsNamespace.on('connection', (socket) => {
    console.log(`[WS] User ${socket.user.username} connected (${socket.id})`);
    
    // Eventos: start_scan, frame, end_scan
  });
}
```

### WebSocket Cliente (apps/web-camera/src/services/websocketService.ts):
```typescript
async connect(): Promise<void> {
  return new Promise((resolve, reject) => {
    const baseUrl = this.config.url.replace(/\/ws$/i, '');
    
    this.socket = io(`${baseUrl}/ws`, {
      auth: this.config.token ? { token: this.config.token } : {},
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5,
    });

    this.socket.on('connect', () => {
      console.log('[WebSocket] ‚úÖ Conectado a', baseUrl);
      this.isConnected = true;
      this.config.onConnect?.();
      resolve();
    });

    this.socket.on('connect_error', (error) => {
      console.error('[WebSocket] ‚ùå Error de conexi√≥n:', error);
      this.config.onError?.(error);
      reject(error);
    });

    this.socket.on('product_detected', (event: ProductDetectedEvent) => {
      console.log('[WebSocket] üéØ Producto detectado:', event.product_name);
      this.config.onProductDetected?.(event);
    });
  });
}
```

### LiveRecording (apps/web-camera/src/pages/LiveRecording.tsx):
```typescript
const WS_URL = import.meta.env.VITE_WS_URL || 'ws://localhost:3001';

useEffect(() => {
  // NO auto-iniciar, esperar clic en "Iniciar"
  console.log('[LiveRecording] Componente montado. Esperando clic en Iniciar...');
  
  return () => {
    cleanup();
  };
}, []);

const initializeSession = async () => {
  try {
    console.log('[LiveRecording] üöÄ Conectando al backend v√≠a WebSocket...');
    
    const wsService = new WebSocketService({
      url: WS_URL,
      onConnect: () => {
        console.log('[LiveRecording] ‚úÖ WebSocket conectado');
        setBackendStatus('connected');
      },
      onDisconnect: () => {
        console.log('[LiveRecording] ‚ùå WebSocket desconectado');
        setBackendStatus('disconnected');
      },
      onProductDetected: handleProductDetected,
    });

    await wsService.connect();
    wsServiceRef.current = wsService;

    const response = await wsService.startScan({
      trolleyId: trolleyId || 1,
      operatorId: operatorId || 1,
    });

    scanIdRef.current = response.scanId;
    setScanId(response.scanId);
    setIsConnected(true);
    
    console.log(`[LiveRecording] ‚úÖ Sesi√≥n iniciada. Scan ID: ${response.scanId}`);
  } catch (error) {
    console.error('[LiveRecording] ‚ùå Error inicializando:', error);
    setError(`Error al conectar: ${error instanceof Error ? error.message : 'Error desconocido'}`);
    setBackendStatus('error');
  }
};

const handleStartRecording = async () => {
  if (!wsServiceRef.current || !scanIdRef.current) {
    await initializeSession();
  }
  
  setIsRecording(true);
  setIsPaused(false);
  console.log('[LiveRecording] ‚ñ∂ Streaming AUTOM√ÅTICO iniciado');
};
```

---

## DEBUGGING

### Logs esperados en consola del navegador (F12):

**Al cargar p√°gina**:
```
[LiveRecording] Componente montado. Esperando clic en Iniciar...
```

**Al hacer clic en "Iniciar"**:
```
[LiveRecording] üöÄ Conectando al backend v√≠a WebSocket...
[WebSocket] ‚úÖ Conectado a ws://localhost:3001
[LiveRecording] ‚úÖ WebSocket conectado
[WebSocket] üì° Enviando start_scan: {trolleyId: 1, operatorId: 1}
[WebSocket] ‚úÖ Scan iniciado: {scanId: 39, status: 'recording'}
[LiveRecording] ‚úÖ Sesi√≥n iniciada. Scan ID: 39
[LiveRecording] ‚ñ∂ Streaming AUTOM√ÅTICO iniciado
[CameraView] üé¨ Streaming iniciado a 2 fps
[LiveRecording] üì∏ Frame 1 capturado...
[LiveRecording] üì° Frame 1 enviado al backend
```

### Logs esperados en backend (terminal):

```
[Gemini] Configurado con modelo: gemini-robotics-er-1.5-preview
[Gemini] URL: https://generativelanguage.googleapis.com/v1beta/models/gemini-robotics-er-1.5-preview:generateContent
‚úÖ Server running on http://localhost:3001
‚úÖ WebSocket available at ws://localhost:3001/ws
[WS] No token provided, using guest user (dev mode)
[WS] User guest connected (abc123)
[WS] Trolley 1 no existe, usando trolley por defecto (si aplica)
[WS] Scan 39 started for trolley 1
[WS] Frame received: frame_1_...
[WS] Product detected: Coca-Cola 350ml (confidence: 0.92)
```

---

## PROMPT DE GEMINI ACTUAL

```javascript
function buildPrompt(catalog) {
  return `Eres un sistema de visi√≥n EN TIEMPO REAL para detecci√≥n de productos en trolleys de catering a√©reo.

TAREA:
Analiza este FRAME y detecta CUALQUIER producto visible de la lista. BUSCA ACTIVAMENTE por COLOR, FORMA y TEXTO del producto.

PRODUCTOS A DETECTAR (bebidas y snacks de avi√≥n):
1. Coca-Cola 350ml ‚Äî Lata roja con logo blanco de Coca-Cola ‚Äî keywords: coca, cola, lata roja, logo blanco
2. Coca-Cola Zero 350ml ‚Äî Lata negra con logo rojo y plata de Coca-Cola Zero ‚Äî keywords: coca, zero, lata negra
3. Sprite 350ml ‚Äî Lata verde con logo Sprite en blanco y amarillo ‚Äî keywords: sprite, lata verde, lim√≥n
4. Pepsi 350ml ‚Äî Lata azul con logo blanco de Pepsi ‚Äî keywords: pepsi, lata azul
5. Agua Natural 500ml ‚Äî Botella de pl√°stico transparente con agua ‚Äî keywords: agua, botella transparente
6. Lays Original 100gr ‚Äî Bolsa de papas amarilla con logo rojo Lays ‚Äî keywords: lays, bolsa amarilla, papas
7. Lays Queso 100gr ‚Äî Bolsa de papas naranja con logo rojo Lays sabor queso ‚Äî keywords: lays, queso, bolsa naranja
8. Doritos Nacho 100gr ‚Äî Bolsa roja con tri√°ngulos amarillos, logo Doritos ‚Äî keywords: doritos, bolsa roja, nacho

INSTRUCCIONES CR√çTICAS:
1. BUSCA por COLOR primero (lata roja, lata verde, lata azul, lata negra, bolsa amarilla, bolsa naranja, bolsa roja)
2. BUSCA por FORMA (latas cil√≠ndricas, botellas, bolsas de papas)
3. BUSCA por TEXTO VISIBLE (Coca-Cola, Sprite, Pepsi, Lays, Doritos, Agua)
4. NO uses c√≥digos de barras ni SKUs
5. Si VES el producto en la imagen, marca detected:true
6. Si puedes, devuelve "box_2d": [ymin, xmin, ymax, xmax] normalizado 0-1000
7. Respuesta JSON ESTRICTA sin code fences

FORMATO DE RESPUESTA (SOLO JSON):
{ "detected": true|false, "product_name": "<nombre_exacto_del_producto>", "confidence": 0.0-1.0, "action": "placing_in_trolley", "box_2d": [ymin, xmin, ymax, xmax] }

Si NO ves ning√∫n producto de la lista:
{ "detected": false }`;
}
```

---

## COMANDOS PARA EJECUTAR

### Ver logs en tiempo real:
```bash
# Terminal 1
tail -f logs/backend.log

# Terminal 2  
tail -f logs/webcam.log
```

### Verificar servicios:
```bash
curl http://localhost:3001
curl http://localhost:3002
```

### Reiniciar todo:
```bash
killall -9 node nodemon vite
sleep 2
./start.sh
```

---

## CHECKLIST DE VERIFICACI√ìN

- [ ] Backend corriendo en puerto 3001
- [ ] Web app corriendo en puerto 3002
- [ ] `apps/api/.env` existe con GEMINI_API_KEY
- [ ] `apps/web-camera/.env` existe con VITE_WS_URL
- [ ] Base de datos tiene 8 productos (verificar con `npx prisma studio`)
- [ ] Usuario `operator1` existe en DB
- [ ] Trolley con ID 1 existe en DB
- [ ] geminiService.js usa `gemini-robotics-er-1.5-preview`
- [ ] Socket.IO CORS permite origen `*`
- [ ] WebSocket namespace es `/ws`
- [ ] Frontend conecta a `ws://localhost:3001/ws`

---

## OBJETIVO FINAL

**Al hacer clic en "‚ñ∂ Iniciar Streaming"**:

1. WebSocket conecta a backend ‚úÖ
2. Sesi√≥n se crea en BD ‚úÖ
3. Streaming inicia a 2 fps ‚úÖ
4. Frames se env√≠an autom√°ticamente ‚úÖ
5. Backend analiza con Gemini ‚úÖ
6. Detecciones aparecen en UI en ~1-2s ‚úÖ
7. Usuario muestra Coca-Cola ‚Üí aparece "Coca-Cola 350ml" ‚úÖ

**TODO AUTOM√ÅTICO despu√©s del clic inicial.**

---

## SOLUCIONES A INTENTAR

### 1. Problema de Conexi√≥n WebSocket:

Si frontend no conecta:

a) Verificar que LiveRecording llame a `initializeSession()` al hacer clic:
```typescript
const handleStartRecording = async () => {
  // Debe llamar esto si no est√° conectado
  if (!wsServiceRef.current || !scanIdRef.current) {
    await initializeSession();
  }
  setIsRecording(true);
};
```

b) Verificar que WebSocketService construya URL correcta:
```typescript
const baseUrl = this.config.url.replace(/\/ws$/i, ''); // ws://localhost:3001
this.socket = io(`${baseUrl}/ws`, {...}); // ws://localhost:3001/ws
```

c) Verificar CORS en backend:
```javascript
cors: {
  origin: '*', // Debe permitir cualquier origen
  methods: ['GET', 'POST'],
}
```

### 2. Problema de Foreign Keys:

Si backend falla al crear scan:

a) Verificar que videoStream.js tenga el c√≥digo de auto-manejo:
```javascript
if (trolleyId) {
  const trolleyExists = await prisma.trolley.findUnique({where: {trolleyId}});
  if (!trolleyExists) {
    let defaultTrolley = await prisma.trolley.findFirst();
    trolleyId = defaultTrolley.trolleyId;
  }
}

if (operatorId) {
  const operatorExists = await prisma.user.findUnique({where: {userId: operatorId}});
  if (!operatorExists) {
    let defaultOperator = await prisma.user.findFirst();
    operatorId = defaultOperator.userId;
  }
}
```

b) Ejecutar seed para asegurar datos:
```bash
node seed-products.js
```

### 3. Problema de Gemini Model:

Si backend tiene error 404:

a) Verificar que geminiService.js tenga:
```javascript
const GEMINI_MODEL = 'gemini-robotics-er-1.5-preview'; // FORZADO
const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;
```

b) Verificar logs del backend para confirmar modelo:
```
[Gemini] Configurado con modelo: gemini-robotics-er-1.5-preview
```

---

## RESULTADO ESPERADO

Despu√©s de hacer clic en "Iniciar Streaming":

```
Estado del Sistema:
‚úÖ Gemini AI: Analizando... (azul pulsando)
‚úÖ Streaming: Backend conectado (verde)
‚úÖ Frames: 5, 6, 7... (incrementando cada 500ms)
‚úÖ Detecciones: 0 ‚Üí 1 ‚Üí 2... (al mostrar productos)
‚úÖ C√°mara: Overlay "Grabando..."

Productos Detectados:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Coca-Cola 350ml        92%  ‚îÇ
‚îÇ 3:58:45 PM                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## COMANDOS PARA DEBUGGING

```bash
# Ver si backend responde
curl http://localhost:3001

# Ver si web app responde
curl http://localhost:3002

# Ver productos en BD
npx prisma studio
# Ir a tabla 'products' y verificar 8 productos

# Ver logs en tiempo real
tail -f logs/backend.log

# Reiniciar todo limpiamente
killall -9 node nodemon vite
./start.sh
```

---

## PRIORIDADES

1. **CR√çTICO**: WebSocket debe conectar desde frontend a backend
2. **CR√çTICO**: Streaming debe iniciar autom√°ticamente al hacer clic
3. **CR√çTICO**: Gemini debe usar modelo `gemini-robotics-er-1.5-preview`
4. **IMPORTANTE**: Detecci√≥n debe ser por COLOR, FORMA y TEXTO
5. **IMPORTANTE**: UI solo con bot√≥n Iniciar/Detener

---

**BRANCH**: `api-streaming-functional`  
**ESTADO**: Backend OK, Frontend no conecta WebSocket  
**OBJETIVO**: Detecci√≥n en tiempo real 100% autom√°tica con Gemini Robotics-ER 1.5

