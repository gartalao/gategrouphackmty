# üéâ ACTUALIZACI√ìN SISTEMA DE VENTAS - DOCUMENTACI√ìN COMPLETA

**Fecha:** 26 de octubre de 2025  
**Versi√≥n:** 2.0.0  
**Estado:** ‚úÖ PRODUCCI√ìN

---

## üìã RESUMEN EJECUTIVO

Se implement√≥ un **sistema completo de rastreo de ventas** con doble escaneo que calcula autom√°ticamente qu√© productos se vendieron durante los vuelos.

### **Funcionalidad Principal:**
```
Scan de CARGA (antes del vuelo) + Scan de RETORNO (despu√©s del vuelo) = VENTAS CALCULADAS
```

---

## üóÑÔ∏è NUEVAS TABLAS EN BASE DE DATOS

### **1. return_scans**
Almacena sesiones de escaneo de productos que QUEDAN despu√©s del vuelo.

```sql
CREATE TABLE "return_scans" (
    "returnScanId" SERIAL PRIMARY KEY,
    "scanId" INTEGER NOT NULL UNIQUE,  -- FK a scans (scan de carga original)
    "started_at" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "ended_at" TIMESTAMP,
    "status" TEXT NOT NULL DEFAULT 'recording',
    "trolleyId" INTEGER,  -- FK a trolleys
    "operatorId" INTEGER,  -- FK a users
    
    FOREIGN KEY ("scanId") REFERENCES "scans"("scanId"),
    FOREIGN KEY ("trolleyId") REFERENCES "trolleys"("trolleyId"),
    FOREIGN KEY ("operatorId") REFERENCES "users"("userId")
);
```

**Campos:**
- `returnScanId`: ID √∫nico del scan de retorno
- `scanId`: Referencia al scan de carga original (UNIQUE - solo 1 retorno por carga)
- `started_at`, `ended_at`: Timestamps de inicio/fin
- `status`: "recording" | "completed"
- `trolleyId`, `operatorId`: Relaciones opcionales

---

### **2. return_detections**
Almacena productos que QUEDARON en el trolley (no se vendieron).

```sql
CREATE TABLE "return_detections" (
    "returnDetectionId" SERIAL PRIMARY KEY,
    "detected_at" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "confidence" DECIMAL(5,4),  -- 0.70 - 1.00
    "video_frame_id" TEXT,
    "returnScanId" INTEGER NOT NULL,  -- FK a return_scans
    "productId" INTEGER NOT NULL,  -- FK a products
    "operatorId" INTEGER,  -- FK a users
    
    FOREIGN KEY ("returnScanId") REFERENCES "return_scans"("returnScanId") ON DELETE CASCADE,
    FOREIGN KEY ("productId") REFERENCES "products"("productId"),
    FOREIGN KEY ("operatorId") REFERENCES "users"("userId"),
    
    UNIQUE ("returnScanId", "productId", "detected_at")
);

CREATE INDEX ON "return_detections"("returnScanId");
CREATE INDEX ON "return_detections"("productId");
```

**Campos:**
- `returnDetectionId`: ID √∫nico de la detecci√≥n
- `returnScanId`: FK al return scan
- `productId`: FK al producto detectado
- `confidence`: Nivel de confianza de Gemini AI
- `videoFrameId`: ID del frame de video
- `operatorId`: Operador que hizo el scan

---

## üîÑ RELACIONES EN PRISMA SCHEMA

```prisma
model User {
  // ... campos existentes
  returnScans      ReturnScan[]
  returnDetections ReturnDetection[]
}

model Product {
  // ... campos existentes
  returnDetections ReturnDetection[]
}

model Trolley {
  // ... campos existentes
  returnScans ReturnScan[]
}

model Scan {
  // ... campos existentes
  returnScan ReturnScan?  // Un scan de carga puede tener UN return scan
}

model ReturnScan {
  returnScanId  Int       @id @default(autoincrement())
  scanId        Int       @unique
  startedAt     DateTime  @default(now())
  endedAt       DateTime?
  status        String    @default("recording")
  
  trolleyId     Int?
  operatorId    Int?
  
  scan          Scan
  trolley       Trolley?
  operator      User?
  detections    ReturnDetection[]
}

model ReturnDetection {
  returnDetectionId Int      @id @default(autoincrement())
  detectedAt        DateTime @default(now())
  confidence        Decimal?
  videoFrameId      String?
  
  returnScanId  Int
  productId     Int
  operatorId    Int?
  
  returnScan    ReturnScan
  product       Product
  operator      User?
}
```

---

## üîå NUEVOS ENDPOINTS API

### **1. GET /api/scans/:scanId/sales-summary**

Obtiene resumen completo de ventas comparando carga vs retorno.

**Request:**
```http
GET http://localhost:3001/api/scans/34/sales-summary
```

**Response:**
```json
{
  "scan": {
    "id": 34,
    "started_at": "2025-10-26T08:09:20Z",
    "ended_at": "2025-10-26T08:09:27Z",
    "status": "completed",
    "trolley": { "trolleyId": 1, "trolleyCode": "TRLLY-001" },
    "operator": { "userId": 1, "username": "operator1" }
  },
  "loaded_products": [
    { "product_id": 9, "product_name": "Coca-Cola Regular Lata", "category": "Bebidas" },
    { "product_id": 20, "product_name": "Doritos Nacho", "category": "Snacks" },
    { "product_id": 23, "product_name": "Santa Clara Chocolate", "category": "Bebidas" }
  ],
  "returned_products": [
    { "product_id": 9, "product_name": "Coca-Cola Regular Lata", "category": "Bebidas" }
  ],
  "sold_products": [
    { "product_id": 20, "product_name": "Doritos Nacho", "category": "Snacks", "unit_price": 25.00 },
    { "product_id": 23, "product_name": "Santa Clara Chocolate", "category": "Bebidas", "unit_price": 15.00 }
  ],
  "stats": {
    "loaded_count": 3,
    "returned_count": 1,
    "sold_count": 2,
    "total_revenue": 40.00,
    "sale_rate": "66.67"
  }
}
```

---

### **2. GET /api/trolleys/:id/sales-history**

Obtiene historial de ventas de un trolley espec√≠fico.

**Request:**
```http
GET http://localhost:3001/api/trolleys/1/sales-history
```

**Response:**
```json
{
  "trolley_id": 1,
  "sales_history": [
    {
      "scan_id": 34,
      "date": "2025-10-26T08:09:20Z",
      "loaded_count": 3,
      "sold_count": 2,
      "revenue": 40.00
    }
  ],
  "total_scans": 5,
  "total_revenue": 250.00
}
```

---

### **3. GET /api/scans**

Lista todos los scans completados.

**Request:**
```http
GET http://localhost:3001/api/scans
```

**Response:**
```json
{
  "scans": [
    {
      "scan_id": 34,
      "trolley": { "trolleyId": 1, "trolleyCode": "TRLLY-001" },
      "operator": { "userId": 1, "username": "operator1" },
      "started_at": "2025-10-26T08:09:20Z",
      "ended_at": "2025-10-26T08:09:27Z",
      "has_return_scan": true,
      "return_scan_status": "completed"
    }
  ],
  "total": 50
}
```

---

## üåê NUEVOS EVENTOS WEBSOCKET

### **1. start_return_scan**

Inicia un escaneo de retorno (productos restantes).

**Emit (Cliente ‚Üí Servidor):**
```typescript
socket.emit('start_return_scan', {
  scanId: 34,  // ID del scan de carga original
  trolleyId: 1,
  operatorId: 1
}, (response) => {
  console.log(response);
  // { returnScanId: 6, scanId: 34, status: 'recording' }
});
```

---

### **2. end_return_scan**

Finaliza un escaneo de retorno.

**Emit (Cliente ‚Üí Servidor):**
```typescript
socket.emit('end_return_scan', {
  returnScanId: 6
}, (response) => {
  console.log(response);
  // { status: 'completed', endedAt: '2025-10-26T08:10:11Z' }
});
```

---

### **3. frame (Modificado)**

Ahora acepta `scanType` para diferenciar entre carga y retorno.

**Emit (Cliente ‚Üí Servidor):**
```typescript
socket.emit('frame', {
  scanId: 6,  // returnScanId si es return, scanId si es load
  frameId: 'frame_42',
  jpegBase64: '...',
  ts: Date.now(),
  scanType: 'return'  // ‚Üê NUEVO: 'load' | 'return'
});
```

---

### **4. product_detected (Modificado)**

Ahora incluye `scan_type` para identificar el tipo de detecci√≥n.

**On (Servidor ‚Üí Cliente):**
```typescript
socket.on('product_detected', (event) => {
  console.log(event);
  /*
  {
    event: 'product_detected',
    scan_type: 'return',  // ‚Üê NUEVO: 'load' | 'return'
    trolley_id: 1,
    product_id: 9,
    product_name: 'Coca-Cola Regular Lata',
    detected_at: '2025-10-26T08:09:55Z',
    operator_id: 1,
    confidence: 0.95,
    box_2d: [...]
  }
  */
});
```

---

## üíª FRONTEND - NUEVAS FUNCIONALIDADES

### **1. UI con 2 Botones (StatusPanel.tsx)**

```typescript
// Bot√≥n 1: Escanear Carga de Trolley (verde)
<button onClick={() => handleStartRecording('load')}>
  üì¶ Escanear Carga de Trolley
</button>

// Bot√≥n 2: Escanear Retorno (azul) 
// - Habilitado solo si hay originalScanId
<button 
  onClick={() => handleStartRecording('return')}
  disabled={!originalScanId}
>
  üîÑ Escanear Retorno (Restantes)
</button>
```

---

### **2. L√≥gica de Ventas (LiveRecording.tsx)**

**Estados Nuevos:**
```typescript
const [scanType, setScanType] = useState<'load' | 'return'>('load');
const [originalScanId, setOriginalScanId] = useState<number | null>(null);
const [loadedProductsMap, setLoadedProductsMap] = useState<Map<number, string>>(new Map());
const [returnedProducts, setReturnedProducts] = useState<Set<number>>(new Set());

// Refs para actualizaci√≥n inmediata
const scanTypeRef = useRef<'load' | 'return'>('load');
```

**Flujo al Iniciar Return Scan:**
```typescript
1. Cargar productos del scan original:
   fetch(`/api/scans/${originalScanId}/summary`)
   
2. Guardar en loadedProductsMap:
   Map { 9 => "Coca-Cola", 20 => "Doritos", 23 => "Santa Clara" }
   
3. Iniciar return scan en backend:
   wsService.startReturnScan({ scanId: 34, trolleyId: 1, operatorId: 1 })
```

**Flujo Durante Return Scan:**
```typescript
onProductDetected (type='return'):
  - Producto detectado: Coca-Cola
  - Agregar a returnedProducts: Set([9])
  - UI muestra: üîÑ Coca-Cola (Retornado)
```

**Flujo al Detener Return Scan:**
```typescript
showSalesSummary():
  1. Calcular vendidos:
     sold = loadedIds - returnedIds
     sold = [9, 20, 23] - [9] = [20, 23]
  
  2. Limpiar UI
  
  3. Mostrar VENDIDOS:
     ‚úÖ Doritos Nacho (VENDIDO)
     ‚úÖ Santa Clara Chocolate (VENDIDO)
  
  4. Mostrar RETORNADOS:
     üîÑ Coca-Cola Regular Lata (Retornado)
```

---

## üé¨ FLUJO COMPLETO DEL SISTEMA

### **Paso 1: Carga del Trolley (Antes del Vuelo)**

```
1. Operador abre: http://localhost:3002
2. Ingresa credenciales:
   - Trolley ID: 1
   - Operator ID: 1
   - Nombre: Juan P√©rez

3. Clic en: üì¶ Escanear Carga de Trolley

4. Sistema:
   - WebSocket conecta
   - Crea Scan #34 (status: recording)
   - Inicia captura de c√°mara (2 fps)

5. Operador escanea productos:
   Frame 5  ‚Üí Coca-Cola detectada   ‚Üí DB: product_detections
   Frame 10 ‚Üí Doritos detectados    ‚Üí DB: product_detections
   Frame 15 ‚Üí Santa Clara detectada ‚Üí DB: product_detections

6. UI muestra:
   üì¶ Coca-Cola Regular Lata (95%)
   üì¶ Doritos Nacho (92%)
   üì¶ Santa Clara Chocolate (90%)

7. Clic en: ‚èπ Detener Streaming

8. Sistema:
   - Scan #34 status ‚Üí completed
   - Guarda originalScanId = 34
   - Bot√≥n "Escanear Retorno" se habilita ‚úÖ
```

---

### **Paso 2: Retorno Despu√©s del Vuelo**

```
1. Operador vuelve despu√©s del vuelo
2. Solo Coca-Cola qued√≥ en el trolley (Doritos y Santa Clara se vendieron)

3. Clic en: üîÑ Escanear Retorno (Restantes)

4. Sistema:
   - Consulta: GET /api/scans/34/summary
   - Carga productos: [Coca-Cola, Doritos, Santa Clara]
   - Guarda en loadedProductsMap
   - Crea ReturnScan #6 (scanId: 34, status: recording)

5. Operador escanea lo que QUED√ì:
   Frame 42 ‚Üí Coca-Cola detectada ‚Üí DB: return_detections

6. UI muestra durante scan:
   üîÑ Coca-Cola Regular Lata (Retornado)

7. Clic en: ‚èπ Detener Streaming

8. Sistema AUTOM√ÅTICO:
   - Calcula: vendidos = [9, 20, 23] - [9] = [20, 23]
   - Limpia UI
   - Muestra resumen:
   
   ‚úÖ Doritos Nacho (VENDIDO)
   ‚úÖ Santa Clara Chocolate (VENDIDO)
   üîÑ Coca-Cola Regular Lata (Retornado)

9. ReturnScan #6 status ‚Üí completed
```

---

### **Paso 3: Consulta de Ventas**

```bash
# Desde el Dashboard o API
curl http://localhost:3001/api/scans/34/sales-summary

{
  "loaded_count": 3,
  "returned_count": 1,
  "sold_count": 2,  ‚úÖ VENDIDOS: Doritos + Santa Clara
  "total_revenue": 40.00,
  "sale_rate": "66.67%"
}
```

---

## üóÇÔ∏è ESTRUCTURA DE DATOS

### **Tablas y Relaciones:**

```
users (operadores)
  ‚Üì
scans (sesiones de carga)
  ‚Üì
product_detections (productos cargados)
  ‚Üì
return_scans (sesiones de retorno) ‚Üê NUEVA
  ‚Üì
return_detections (productos retornados) ‚Üê NUEVA
```

### **C√°lculo de Ventas:**

```javascript
// En memoria (no se guarda en tabla)
const loaded = await productDetection.findMany({ where: { scanId: 34 } });
const returned = await returnDetection.findMany({ where: { returnScanId: 6 } });

const soldIds = loaded
  .map(d => d.productId)
  .filter(id => !returned.some(r => r.productId === id));

// sold = productos que estaban en loaded pero NO en returned
```

---

## üì° ARCHIVOS MODIFICADOS/CREADOS

### **Backend:**

#### ‚úÖ `prisma/schema.prisma`
- Agregadas tablas: `ReturnScan`, `ReturnDetection`
- Actualizadas relaciones en: `User`, `Product`, `Trolley`, `Scan`

#### ‚úÖ `apps/api/routes/salesTracking.js` (NUEVO)
- GET `/api/scans/:scanId/sales-summary`
- GET `/api/trolleys/:id/sales-history`
- GET `/api/scans`

#### ‚úÖ `apps/api/routes/videoStream.js`
- Evento `start_return_scan` (crear return scan)
- Evento `end_return_scan` (finalizar return scan)
- Evento `frame` modificado (acepta scanType, guarda en tabla correcta)
- Validaci√≥n de trolleyId/operatorId existentes

#### ‚úÖ `apps/api/src/index.js`
- Rutas de `salesTracking` agregadas

---

### **Frontend:**

#### ‚úÖ `apps/web-camera/src/services/websocketService.ts`
- `startReturnScan()`: Iniciar scan de retorno
- `endReturnScan()`: Finalizar scan de retorno
- Interface `StartReturnScanParams`
- Interface `FrameParams` con `scanType?`

#### ‚úÖ `apps/web-camera/src/components/StatusPanel.tsx`
- 2 botones en lugar de 1
- Props: `onStartLoadScan`, `onStartReturnScan`, `hasOriginalScan`
- Bot√≥n retorno habilitado solo si hay scan previo
- Mensaje informativo

#### ‚úÖ `apps/web-camera/src/pages/LiveRecording.tsx`
- **States:**
  - `scanType`: 'load' | 'return'
  - `originalScanId`: ID del scan de carga
  - `loadedProductsMap`: Map de productos cargados
  - `returnedProducts`: Set de productos retornados
  
- **Refs:**
  - `scanTypeRef`: Para actualizaci√≥n inmediata sin delay

- **Funciones Nuevas:**
  - `handleStartRecording(type)`: Maneja ambos tipos de scan
  - `initializeSession(type)`: Crea load scan o return scan
  - `calculateAndShowSoldProducts()`: Calcula vendidos en tiempo real
  - `showSalesSummary()`: Muestra resumen final de ventas

- **Modificaciones:**
  - `handleProductDetected()`: Detecta tipo de scan y maneja diferente
  - `handleStopRecording()`: Llama a `showSalesSummary()` si es return
  - `handleFrameCapture()`: Env√≠a `scanTypeRef.current`

---

### **Utilidades:**

#### ‚úÖ `test-sales-calculation.js` (NUEVO)
Script de testing para verificar c√°lculo de ventas.

```bash
# Ver scans disponibles
node test-sales-calculation.js

# Analizar scan espec√≠fico
node test-sales-calculation.js 34
```

---

## üéØ CARACTER√çSTICAS DEL SISTEMA

### ‚úÖ **Lo que hace el proyecto:**

#### **1. Detecci√≥n en Tiempo Real**
- C√°mara captura frames a 2 fps (500ms)
- Frames se env√≠an v√≠a WebSocket al backend
- Backend analiza con **Gemini Robotics-ER 1.5 Premium**
- Detecci√≥n multi-objeto (varios productos en 1 frame)
- Confianza: 70-100%

#### **2. Sistema de Doble Escaneo**
- **Scan de Carga:** Productos que ENTRAN al trolley
- **Scan de Retorno:** Productos que QUEDAN despu√©s del vuelo
- **C√°lculo Autom√°tico:** Vendidos = Cargados - Retornados

#### **3. Tracking √önico por Sesi√≥n**
- Cada producto se registra **solo 1 vez** por scan
- Multi-producto simult√°neo soportado
- 3 capas de protecci√≥n anti-duplicados

#### **4. WebSocket en Tiempo Real**
- Cliente ‚Üî Servidor comunicaci√≥n bidireccional
- Eventos: `start_scan`, `frame`, `product_detected`, `end_scan`
- Eventos nuevos: `start_return_scan`, `end_return_scan`

#### **5. Base de Datos Neon PostgreSQL**
- 9 tablas relacionales
- Prisma ORM para queries type-safe
- √çndices optimizados para performance

#### **6. API REST Completa**
- Endpoints de detecciones en tiempo real
- Endpoints de historial
- Endpoints de an√°lisis de ventas
- Res√∫menes de scans

---

## üìä MODELO DE DATOS COMPLETO

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Users     ‚îÇ (Operadores)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ                                 ‚îÇ
       ‚ñº                                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Scans     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ ReturnScans  ‚îÇ
‚îÇ  (Carga)    ‚îÇ                   ‚îÇ  (Retorno)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                                 ‚îÇ
       ‚îÇ                                 ‚îÇ
       ‚ñº                                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ProductDetections‚îÇ           ‚îÇ ReturnDetections    ‚îÇ
‚îÇ   (Cargados)     ‚îÇ           ‚îÇ   (Retornados)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ                              ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ  Products   ‚îÇ
              ‚îÇ (Cat√°logo)  ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Trolleys   ‚îÇ (Carritos)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Flights   ‚îÇ (Vuelos)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FlightRequirements   ‚îÇ
‚îÇ (Productos esperados)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üß™ TESTING Y VERIFICACI√ìN

### **Script de Testing:**
```bash
# Ver scans con retorno
node test-sales-calculation.js

# Analizar ventas de scan espec√≠fico
node test-sales-calculation.js 34
```

### **Testing Manual:**
1. Scan de carga ‚Üí 3 productos
2. Scan de retorno ‚Üí 1 producto
3. Verificar UI muestra 2 vendidos
4. Consultar API: `/api/scans/34/sales-summary`
5. Verificar stats: `sold_count: 2`

---

## üîß CONFIGURACI√ìN T√âCNICA

### **Backend:**
```env
PORT=3001
DATABASE_URL=postgresql://...
GEMINI_API_KEY=...
GEMINI_MODEL=gemini-robotics-er-1.5-preview
CONFIDENCE_THRESHOLD=0.70
JWT_SECRET=...
```

### **Frontend:**
```env
VITE_WS_URL=ws://localhost:3001
VITE_GEMINI_API_KEY=...
```

### **Captura:**
- Resoluci√≥n: 1280x720
- Frame rate: 30 fps (captura)
- Env√≠o: 2 fps (500ms) - optimizado para Gemini Premium (120 RPM)

---

## üìà M√âTRICAS Y KPIs

### **Para el Dashboard:**

```typescript
const kpis = {
  // KPIs B√°sicos
  "productos_unicos": loaded_count,
  "total_detecciones": detections.length,
  "confianza_promedio": avg_confidence,
  "tiempo_sesion": duration,
  
  // KPIs de Ventas (NUEVOS)
  "productos_vendidos": sold_count,
  "productos_retornados": returned_count,
  "tasa_de_venta": sale_rate,
  "revenue_total": total_revenue,
  
  // An√°lisis
  "categoria_mas_vendida": "Snacks",
  "producto_mas_vendido": "Doritos Nacho",
}
```

---

## üöÄ STACK TECNOL√ìGICO

```
BACKEND:
‚îú‚îÄ‚îÄ Node.js 22.18.0
‚îú‚îÄ‚îÄ Express 4.18.2
‚îú‚îÄ‚îÄ Socket.IO 4.7.5
‚îú‚îÄ‚îÄ Prisma 5.22.0
‚îú‚îÄ‚îÄ PostgreSQL (Neon)
‚îî‚îÄ‚îÄ Google Gemini AI (Robotics-ER 1.5)

FRONTEND:
‚îú‚îÄ‚îÄ React 18.2.0
‚îú‚îÄ‚îÄ TypeScript 5.2.2
‚îú‚îÄ‚îÄ Vite 5.0.8
‚îú‚îÄ‚îÄ TailwindCSS 3.4.0
‚îú‚îÄ‚îÄ Socket.IO Client 4.7.5
‚îî‚îÄ‚îÄ Lucide Icons

DATABASE:
‚îî‚îÄ‚îÄ Neon PostgreSQL
    ‚îî‚îÄ‚îÄ 9 tablas (2 nuevas)
```

---

## üìä TABLAS DE LA BASE DE DATOS

### **Existentes:**
1. `users` - Operadores del sistema
2. `products` - Cat√°logo de 20 productos
3. `flights` - Vuelos (AA2345, AM0876, etc.)
4. `trolleys` - Carritos (TRLLY-001, TRLLY-002, etc.)
5. `flight_requirements` - Productos requeridos por vuelo
6. `scans` - Sesiones de escaneo de carga
7. `product_detections` - Productos detectados en carga

### **Nuevas (Sistema de Ventas):**
8. `return_scans` - Sesiones de escaneo de retorno ‚ú®
9. `return_detections` - Productos detectados en retorno ‚ú®

---

## üí° L√ìGICA DE C√ÅLCULO DE VENTAS

```javascript
// NO HAY TABLA "sold_products"
// Los vendidos se calculan din√°micamente:

function calculateSales(scanId) {
  // 1. Obtener productos cargados
  const loaded = await prisma.productDetection.findMany({
    where: { scanId }
  });
  const loadedIds = loaded.map(d => d.productId);
  
  // 2. Obtener productos retornados
  const returnScan = await prisma.returnScan.findUnique({
    where: { scanId },
    include: { detections: true }
  });
  const returnedIds = returnScan.detections.map(d => d.productId);
  
  // 3. Calcular vendidos (diferencia)
  const soldIds = loadedIds.filter(id => !returnedIds.includes(id));
  
  // 4. Obtener detalles de vendidos
  const sold = loaded.filter(d => soldIds.includes(d.productId));
  
  return {
    loaded: loaded.length,
    returned: returnedIds.length,
    sold: sold.length,
    sold_products: sold
  };
}
```

---

## üé® UI/UX MEJORADA

### **Indicadores Visuales:**

```
üì¶ = Producto CARGADO (verde)
üîÑ = Producto RETORNADO (azul)
‚úÖ = Producto VENDIDO (dorado)
```

### **Mensajes en Consola:**

```
[CARGA] Producto agregado: Coca-Cola
[RETORNO] Producto retornado: Coca-Cola
üí∞ Productos vendidos calculados: 2
üìä Resumen: Cargados: 3 | Retornados: 1 | VENDIDOS: 2
```

---

## üîí VALIDACIONES Y SEGURIDAD

### **Backend:**
- ‚úÖ Validaci√≥n de trolleyId existe antes de crear return scan
- ‚úÖ Validaci√≥n de operatorId existe antes de crear return scan
- ‚úÖ Verificaci√≥n de scan original existe
- ‚úÖ Prevenci√≥n de duplicados (returnScanId UNIQUE por scanId)
- ‚úÖ Rate limiting de Gemini API (120 RPM)

### **Frontend:**
- ‚úÖ Bot√≥n retorno deshabilitado si no hay scan previo
- ‚úÖ Validaci√≥n de originalScanId antes de iniciar return
- ‚úÖ Deduplicaci√≥n de productos detectados
- ‚úÖ Limpieza de listeners de Socket.IO

---

## üéØ CASOS DE USO

### **Caso 1: Venta Total**
```
Cargados:   [Coca, Doritos, Takis]
Retornados: []
Vendidos:   [Coca, Doritos, Takis]  ‚úÖ 100%
```

### **Caso 2: Venta Parcial**
```
Cargados:   [Coca, Doritos, Takis]
Retornados: [Coca]
Vendidos:   [Doritos, Takis]  ‚úÖ 66.67%
```

### **Caso 3: Sin Ventas**
```
Cargados:   [Coca, Doritos, Takis]
Retornados: [Coca, Doritos, Takis]
Vendidos:   []  ‚ùå 0%
```

---

## üìö DOCUMENTACI√ìN RELACIONADA

- `DETECCION_UNICA_IMPLEMENTADA.md` - Sistema de detecci√≥n √∫nica
- `DISE√ëO_SISTEMA_VENTAS.md` - Arquitectura del sistema de ventas
- `SISTEMA_VENTAS_COMPLETO.md` - Gu√≠a de uso completa
- `FLUJO_VENTAS_UI.md` - Flujo de UI y UX
- `PROMPT_V0_DASHBOARD.md` - Dashboard con v0 de Vercel
- `RESUMEN_SESION_CURSOR.md` - Sesi√≥n anterior

---

## üöÄ COMANDOS √öTILES

```bash
# Reiniciar sistema
killall -9 node nodemon vite
./start.sh

# Ver logs
tail -f logs/backend.log
tail -f logs/webcam.log

# Testing de ventas
node test-sales-calculation.js <scanId>

# Limpiar base de datos
node -e "const {PrismaClient} = require('./generated/prisma'); const prisma = new PrismaClient(); (async () => { await prisma.returnDetection.deleteMany({}); await prisma.returnScan.deleteMany({}); await prisma.productDetection.deleteMany({}); await prisma.scan.deleteMany({}); await prisma.\$disconnect(); })()"

# Consultar ventas
curl http://localhost:3001/api/scans/<scanId>/sales-summary | jq

# Ver scans con retorno
curl http://localhost:3001/api/scans | jq '.scans[] | select(.has_return_scan == true)'
```

---

## ‚ú® FEATURES IMPLEMENTADAS

### ‚úÖ **Core Features:**
1. Detecci√≥n visual con Gemini AI
2. WebSocket en tiempo real
3. Base de datos PostgreSQL
4. UI responsive con React + TypeScript
5. Sistema de detecci√≥n √∫nica por sesi√≥n

### ‚úÖ **Features de Ventas (NUEVAS):**
6. Doble escaneo (carga + retorno)
7. C√°lculo autom√°tico de productos vendidos
8. UI muestra vendidos al finalizar retorno
9. API de an√°lisis de ventas
10. Historial de ventas por trolley
11. KPIs de revenue y tasa de venta

---

## üéØ PARA EL DASHBOARD

El dashboard debe consumir estos endpoints:

```typescript
// Resumen de ventas de un scan
GET /api/scans/:scanId/sales-summary

// KPIs a mostrar:
- Productos Cargados: loaded_count
- Productos Vendidos: sold_count
- Tasa de Venta: sale_rate
- Revenue Total: total_revenue

// Gr√°ficas:
- Barras: Cargados vs Retornados vs Vendidos
- Pie chart: Distribuci√≥n por categor√≠a
- L√≠nea temporal: Ventas por hora/d√≠a

// Checklist:
sold_products.map(p => ({
  name: p.product_name,
  status: 'vendido',
  icon: '‚úÖ'
}))

returned_products.map(p => ({
  name: p.product_name,
  status: 'retornado',
  icon: 'üîÑ'
}))
```

---

## üèÜ IMPACTO DEL SISTEMA

### **Antes (Sin Sistema de Ventas):**
- Solo detectaba productos al cargar
- No sab√≠a qu√© se vendi√≥
- No hab√≠a m√©tricas de ventas
- Inventario manual

### **Ahora (Con Sistema de Ventas):**
- ‚úÖ Detecta carga autom√°ticamente
- ‚úÖ Detecta retorno autom√°ticamente
- ‚úÖ **Calcula ventas en tiempo real**
- ‚úÖ Revenue y tasa de venta autom√°ticos
- ‚úÖ An√°lisis de productos m√°s vendidos
- ‚úÖ Optimizaci√≥n de inventario basada en datos
- ‚úÖ Reportes autom√°ticos por vuelo/trolley

---

## üìû ENDPOINTS SUMMARY

```
BASE URL: http://localhost:3001

DETECCIONES:
  GET  /api/trolleys/:id/realtime-status
  GET  /api/trolleys/:id/detections
  GET  /api/scans/:id/summary

VENTAS (NUEVOS):
  GET  /api/scans/:scanId/sales-summary
  GET  /api/trolleys/:id/sales-history
  GET  /api/scans

WEBSOCKET: ws://localhost:3001/ws
  Events: start_scan, frame, end_scan, product_detected
  Events (NUEVOS): start_return_scan, end_return_scan
```

---

## ‚úÖ ESTADO DEL PROYECTO

**Versi√≥n:** 2.0.0  
**Backend:** ‚úÖ Funcionando (puerto 3001)  
**Frontend:** ‚úÖ Funcionando (puerto 3002)  
**Database:** ‚úÖ Sincronizada (Neon PostgreSQL)  
**Gemini AI:** ‚úÖ Premium 120 RPM  
**Sistema de Ventas:** ‚úÖ Completamente funcional  

---

## üéâ RESUMEN FINAL

**El proyecto Smart Trolley ahora es un sistema completo de:**

1. ‚úÖ Detecci√≥n autom√°tica de productos (Gemini AI)
2. ‚úÖ Tracking en tiempo real (WebSocket)
3. ‚úÖ An√°lisis de ventas (Doble escaneo)
4. ‚úÖ C√°lculo de revenue (Autom√°tico)
5. ‚úÖ Dashboard analytics (API completa)

**Listo para producci√≥n y demo en HackMTY! üèÜ**

